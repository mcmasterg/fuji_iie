/* All Apple ][e variants include a single PAL that derives clock from the
 * main 14.318MHz system clock and generates other timing-critical control
 * signals.
 *
 * Note: clocks generated by this PAL need their corresponding generated
 * clock constraints added via an SDC or XDC.  See constraints/apple_ii_pal.xdc.
 */

module AppleIIePAL(
    input clk_14M,

    output reg clk_7M,
    output clk_3_58M,
    output reg clk_q3,
    output clk_phi_0,

    // RAM address strobes
    input clk_phi_1,
    input ramen_n,
    output reg pcas_n,
    output reg pras_n,

    input vid7,
    input gr,
    input eighty_vid_n,
    input entmg,

    output h0,
    output segb,
    output ldps_n,
    output vid7m
    );

    always @(posedge clk_14M)
    clk_7M <= ~clk_7M;

    ClockDivideByN #(
        .N(14)
    ) phi_0_divider(
        .clk_in(clk_14M),
        .reset(1'b0),
        .clk_out(clk_phi_0)
    );

    // Q3's asymmetric waveform edges are always aligned with positive edges
    // of 14M. Counting those edges is sufficient to generate both periods of
    // Q3.  RAS pulses high for 2 14M periods centered on Q3's rising edge.
    reg [3:0] q3_counter;
    always @(posedge clk_14M) begin
        if (q3_counter < 4'd4) clk_q3 <= 1'b1;
        else clk_q3 <= 1'b0;

        if (q3_counter >= 4'd6) q3_counter <= 0;
        else q3_counter <= q3_counter + 1;
    end

    // RAS# goes high 2 14M cycles after Q3 goes low and remains high for
    // 2 14M cycles.
    reg pras_counter;
    always @(posedge clk_14M) begin
        if (~pras_n && ~clk_q3) begin
            if (~pras_counter) pras_counter <= 1'b1;
            else begin
                pras_counter <= 1'b0;
                pras_n <= 1'b1;
            end
        end
        else if (pras_n) begin
            if (~pras_counter) pras_counter <= 1'b1;
            else begin
                pras_counter <= 1'b0;
                pras_n <= 1'b0;
            end
        end
    end

    // If RAMEN# is low, CAS# goes high on the rising edge of 14M when RAS# is
    // also high.  It remains high for 3 14M periods.  If RAMEN# is high, CAS#
    // is held high to prevent the RAMs from enabling their outputs.
    reg [1:0] pcas_counter;
    always @(posedge clk_14M) begin
        if (ramen_n) pcas_n <= 1'b1;
        else begin
            if (pras_n) begin
                pcas_counter <= 2'b0;
                pcas_n <= 1'b1;
            end
            else if (pcas_n) begin
                if (pcas_counter < 2'd2) pcas_counter <= pcas_counter + 1;
                else pcas_n <= 1'b0;
            end
        end
    end
endmodule
